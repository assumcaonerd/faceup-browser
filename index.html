<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Face Swap – Browser Only</title>
<style>
  :root { color-scheme: dark light; }
  body{font-family:system-ui,Arial,sans-serif; margin:24px; background:#0b1220; color:#e7eefc}
  h1{margin:0 0 12px}
  .grid{display:grid; gap:16px; grid-template-columns:1fr 1fr}
  .card{background:#0e1a33; border:1px solid #213459; border-radius:16px; padding:12px}
  .card h3{margin:6px 0 10px}
  canvas, img{width:100%; max-height:60vh; object-fit:contain; background:#0b0f1d; border-radius:12px}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  button{background:#3b82f6; color:white; border:none; padding:10px 14px; border-radius:12px; font-weight:700; cursor:pointer}
  button[disabled]{opacity:.5; cursor:not-allowed}
  .pill{font-size:12px; opacity:.85}
  .footer{opacity:.8; margin-top:10px}
  a{color:#8ab4ff}
</style>
</head>
<body>
  <h1>Face Swap – Browser</h1>
  <div class="row">
    <button id="swapBtn" disabled>Swap Faces</button>
    <button id="downloadBtn" disabled>Baixar PNG</button>
    <span id="status" class="pill">Carregue as duas imagens.</span>
  </div>

  <div class="grid">
    <div class="card">
      <h3>Imagem FONTE (rosto que entra)</h3>
      <input type="file" id="srcFile" accept="image/*" />
      <img id="srcImg" alt="Fonte" />
    </div>
    <div class="card">
      <h3>Imagem ALVO (foto final)</h3>
      <input type="file" id="tgtFile" accept="image/*" />
      <img id="tgtImg" alt="Alvo" />
    </div>
  </div>

  <div class="card" style="margin-top:16px">
    <h3>Resultado</h3>
    <canvas id="outCanvas"></canvas>
    <div class="footer">
      Dica: rostos de frente ou 3/4, boa iluminação. Pinte só o rosto (automático) — cabelo/orelhas ficam do ALVO.
      Use com consentimento dos envolvidos.
    </div>
  </div>

  <!-- MediaPipe FaceMesh (landmarks) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <!-- Delaunay triangulation -->
  <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.0/delaunator.min.js"></script>

<script>
/* =========================
   Utils
========================= */
const $ = sel => document.querySelector(sel);
const statusEl = $("#status");
const srcImg = $("#srcImg"), tgtImg = $("#tgtImg");
const outCanvas = $("#outCanvas"), ctxOut = outCanvas.getContext("2d");
const swapBtn = $("#swapBtn"), dlBtn = $("#downloadBtn");

let srcLoaded=false, tgtLoaded=false;

function loadImageToTag(file, imgTag, cb){
  const r = new FileReader();
  r.onload = e => { imgTag.src = e.target.result; imgTag.onload = () => cb?.(); };
  r.readAsDataURL(file);
}

$("#srcFile").addEventListener("change", e=>{
  if(!e.target.files[0]) return;
  loadImageToTag(e.target.files[0], srcImg, ()=>{srcLoaded=true; maybeEnable();});
});

$("#tgtFile").addEventListener("change", e=>{
  if(!e.target.files[0]) return;
  loadImageToTag(e.target.files[0], tgtImg, ()=>{tgtLoaded=true; maybeEnable();});
});

function maybeEnable(){
  if(srcLoaded && tgtLoaded){
    swapBtn.disabled=false;
    statusEl.textContent="Pronto para trocar. Clique em ‘Swap Faces’.";
  }
}

/* =========================
   FaceMesh setup
========================= */
const faceMesh = new FaceMesh.FaceMesh({
  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
});

faceMesh.setOptions({
  maxNumFaces: 1,
  refineLandmarks: true,   // olhos/boca refinados
  minDetectionConfidence: 0.5,
  minTrackingConfidence: 0.5
});

function getLandmarksFromImage(img){
  return new Promise((resolve,reject)=>{
    const tmpCanvas = document.createElement("canvas");
    const tctx = tmpCanvas.getContext("2d");
    tmpCanvas.width = img.naturalWidth;
    tmpCanvas.height = img.naturalHeight;
    tctx.drawImage(img,0,0);
    faceMesh.onResults((res)=>{
      if(res.multiFaceLandmarks && res.multiFaceLandmarks.length){
        // Retorna [ {x,y,z} ... ] no espaço normalizado 0..1
        const lm = res.multiFaceLandmarks[0].map(p=>({
          x: p.x * tmpCanvas.width,
          y: p.y * tmpCanvas.height
        }));
        resolve({landmarks: lm, width: tmpCanvas.width, height: tmpCanvas.height, canvas: tmpCanvas});
      }else{
        reject(new Error("Rosto não detectado."));
      }
    });
    // MediaPipe espera uma imagem HTMLVideoElement/HTMLImageElement/HTMLCanvasElement
    faceMesh.send({image: img});
  });
}

/* =========================
   Triangulation indices (468 pts). Usaremos subconjunto (malha densa)
========================= */
// Usaremos todos os pontos e deixamos Delaunay construir triângulos.
function triangulate(points){
  const coords = points.flatMap(p=>[p.x,p.y]);
  const dela = new Delaunator(coords);
  return dela.triangles; // indices em trincas
}

/* =========================
   Affine warp por triângulos
========================= */
function drawTriangleWarp(srcCtx, dstCtx, srcTri, dstTri){
  // srcTri/dstTri: [{x,y},{x,y},{x,y}]
  // baseados em https://github.com/spite/ccapture.js/wiki/Canvas-affine-transform
  // Matriz de transformação afim
  const [s0,s1,s2] = srcTri, [d0,d1,d2] = dstTri;
  dstCtx.save();
  dstCtx.beginPath();
  dstCtx.moveTo(d0.x, d0.y);
  dstCtx.lineTo(d1.x, d1.y);
  dstCtx.lineTo(d2.x, d2.y);
  dstCtx.closePath();
  dstCtx.clip();

  // Resolver transform afim que mapeia src->dst
  const denom = (s0.x*(s1.y - s2.y) + s1.x*(s2.y - s0.y) + s2.x*(s0.y - s1.y));
  if (Math.abs(denom) < 1e-3){ dstCtx.restore(); return; }

  const a = (d0.x*(s1.y - s2.y) + d1.x*(s2.y - s0.y) + d2.x*(s0.y - s1.y)) / denom;
  const b = (d0.y*(s1.y - s2.y) + d1.y*(s2.y - s0.y) + d2.y*(s0.y - s1.y)) / denom;
  const c = (d0.x*(s2.x - s1.x) + d1.x*(s0.x - s2.x) + d2.x*(s1.x - s0.x)) / denom;
  const d = (d0.y*(s2.x - s1.x) + d1.y*(s0.x - s2.x) + d2.y*(s1.x - s0.x)) / denom;
  const e = (d0.x*(s1.x*s2.y - s2.x*s1.y) + d1.x*(s2.x*s0.y - s0.x*s2.y) + d2.x*(s0.x*s1.y - s1.x*s0.y)) / denom;
  const f = (d0.y*(s1.x*s2.y - s2.x*s1.y) + d1.y*(s2.x*s0.y - s0.x*s2.y) + d2.y*(s0.x*s1.y - s1.x*s0.y)) / denom;

  dstCtx.transform(a, b, c, d, e, f);
  // Desenhar a imagem de origem inteira; a clip limita ao triângulo
  dstCtx.drawImage(srcCtx.canvas, 0, 0);
  dstCtx.restore();
}

/* =========================
   Máscara do rosto (feather)
========================= */
function drawSoftMask(ctx, points, featherPx=6){
  ctx.save();
  ctx.fillStyle="black";
  ctx.globalCompositeOperation="destination-in";
  ctx.beginPath();
  // contorno aproximado: oval via hull de bochecha/queixo/testa (subconjunto dos landmarks)
  // Pegamos um conjunto denso: bochechas 50..280 (aprox) – para simplificar, use oval automático:
  const w = ctx.canvas.width, h = ctx.canvas.height;
  // bounding box dos landmarks (com margem)
  const xs = points.map(p=>p.x), ys = points.map(p=>p.y);
  const minX = Math.max(0, Math.min(...xs)-10), maxX = Math.min(w, Math.max(...xs)+10);
  const minY = Math.max(0, Math.min(...ys)-20), maxY = Math.min(h, Math.max(...ys)+10);
  // desenha oval
  const cx = (minX+maxX)/2, cy = (minY+maxY)/2;
  const rx = (maxX-minX)/2, ry = (maxY-minY)/2;
  // caminho de oval
  const steps=64;
  for(let i=0;i<=steps;i++){
    const t=i/steps*2*Math.PI;
    const x = cx + rx*Math.cos(t);
    const y = cy + ry*Math.sin(t);
    i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
  }
  ctx.closePath();
  ctx.fill();
  // feather leve nas bordas
  if (featherPx>0){
    ctx.globalCompositeOperation="destination-out";
    const grad = ctx.createRadialGradient(cx,cy,Math.max(rx,ry)-featherPx,cx,cy,Math.max(rx,ry)+1);
    grad.addColorStop(0,"transparent");
    grad.addColorStop(1,"rgba(0,0,0,1)");
    ctx.fillStyle=grad;
    ctx.beginPath();
    ctx.arc(cx,cy,Math.max(rx,ry)+featherPx,0,2*Math.PI);
    ctx.fill();
  }
  ctx.restore();
}

/* =========================
   Correção de cor simples (match média e std)
========================= */
function colorMatch(srcCtx, dstCtx, maskCtx){
  // Faz matching nos canais RGB dentro da máscara
  const w = dstCtx.canvas.width, h = dstCtx.canvas.height;
  const sData = srcCtx.getImageData(0,0,w,h), dData = dstCtx.getImageData(0,0,w,h), mData = maskCtx.getImageData(0,0,w,h);
  const sArr = sData.data, dArr = dData.data, mArr = mData.data;

  function stats(arr, ch){
    let sum=0, sum2=0, n=0;
    for(let i=0;i<arr.length;i+=4){
      if(mArr[i+3]>0){ // dentro da máscara
        const v = arr[i+ch];
        sum+=v; sum2+=v*v; n++;
      }
    }
    const mean = sum/Math.max(1,n);
    const std = Math.sqrt(Math.max(1e-6, sum2/Math.max(1,n) - mean*mean));
    return {mean,std};
  }

  const sR=stats(sArr,0), sG=stats(sArr,1), sB=stats(sArr,2);
  const dR=stats(dArr,0), dG=stats(dArr,1), dB=stats(dArr,2);

  const out = dData.data;
  for(let i=0;i<out.length;i+=4){
    if(mArr[i+3]>0){
      // normaliza destino e aplica média/var da fonte
      const r = (dArr[i]-dR.mean)/Math.max(1e-6,dR.std)*sR.std + sR.mean;
      const g = (dArr[i+1]-dG.mean)/Math.max(1e-6,dG.std)*sG.std + sG.mean;
      const b = (dArr[i+2]-dB.mean)/Math.max(1e-6,dB.std)*sB.std + sB.mean;
      out[i]   = Math.max(0,Math.min(255,r));
      out[i+1] = Math.max(0,Math.min(255,g));
      out[i+2] = Math.max(0,Math.min(255,b));
      out[i+3] = dArr[i+3];
    }
  }
  dstCtx.putImageData(dData,0,0);
}

/* =========================
   Main swap
========================= */
async function doSwap(){
  try{
    swapBtn.disabled=true; dlBtn.disabled=true;
    statusEl.textContent="Detectando rostos...";
    // Landmarks
    const src = await getLandmarksFromImage(srcImg);
    const tgt = await getLandmarksFromImage(tgtImg);

    // Canvas de trabalho (origens)
    const srcCtx = src.canvas.getContext("2d");
    const tgtCtx = document.createElement("canvas").getContext("2d");
    tgtCtx.canvas.width = tgt.width; tgtCtx.canvas.height = tgt.height;
    tgtCtx.drawImage(tgtImg,0,0);

    // Saída = cópia do alvo
    outCanvas.width = tgt.width; outCanvas.height = tgt.height;
    ctxOut.clearRect(0,0,outCanvas.width,outCanvas.height);
    ctxOut.drawImage(tgtImg,0,0);

    statusEl.textContent="Triangulando...";
    const tris = triangulate(tgt.landmarks);

    statusEl.textContent="Aplicando warp por triângulos...";
    // Warp cada triângulo do rosto da fonte para o alvo
    for(let i=0;i<tris.length;i+=3){
      const ia = tris[i], ib = tris[i+1], ic = tris[i+2];
      const dstTri = [tgt.landmarks[ia], tgt.landmarks[ib], tgt.landmarks[ic]];
      const srcTri = [src.landmarks[ia], src.landmarks[ib], src.landmarks[ic]];
      drawTriangleWarp(srcCtx, ctxOut, srcTri, dstTri);
    }

    // Criar máscara suave do rosto (para aparecer cabelo/orelhas do alvo)
    const mask = document.createElement("canvas").getContext("2d");
    mask.canvas.width = tgt.width; mask.canvas.height = tgt.height;
    drawSoftMask(mask, tgt.landmarks, 8);

    // Aplicar máscara (mantendo só a área do rosto trocado)
    const blended = document.createElement("canvas").getContext("2d");
    blended.canvas.width=tgt.width; blended.canvas.height=tgt.height;
    blended.drawImage(ctxOut.canvas,0,0);
    blended.globalCompositeOperation="destination-in";
    blended.drawImage(mask.canvas,0,0);

    // Sobrepor no alvo original
    ctxOut.clearRect(0,0,outCanvas.width,outCanvas.height);
    ctxOut.drawImage(tgtImg,0,0);
    ctxOut.globalCompositeOperation="source-over";
    ctxOut.drawImage(blended.canvas,0,0);

    // Correção de cor leve (para equalizar pele)
    colorMatch(srcCtx, ctxOut, mask);

    statusEl.textContent="Pronto! Se quiser, ajuste as imagens e tente novamente.";
    dlBtn.disabled=false;
  }catch(err){
    console.error(err);
    statusEl.textContent = "Falha: " + err.message + " (Tente outra foto com rosto mais frontal e iluminado.)";
  }finally{
    swapBtn.disabled=false;
  }
}

swapBtn.addEventListener("click", doSwap);
dlBtn.addEventListener("click", ()=>{
  const a = document.createElement("a");
  a.href = outCanvas.toDataURL("image/png");
  a.download = "face-swap.png";
  a.click();
});
</script>
</body>
</html>
